Cоздаем новый проект PyCharm, в нем должно быть установлено и активировано виртуальное окружение.

Включаем систему контроля версий VCS (GIT), создаем файл .gitignore и вносим исключения

Дальнейшие действия выполняем в активированной виртуальной среде.

Установка Django:

        pip install django

Делаем коммит:

        git commit

Импортируем проект в удаленный репозиторий:

        PyCharm -> VSC -> Import into Version Control -> Share Project on GitHub

Cоздаем папку с именем learning_log и в ней создаем проект с именем learning_log (с точкой в конце):

        django-admin startproject learning_log .

Django создает новый каталог с именем learning_log. Также создается файл manage.py — короткая программа, которая
получает команды и передает их соответствующей части Django для выполнения.
Мы используем эти команды для управления такими задачами, как работа с базами данных и запуск серверов.
В каталоге learning_log находятся четыре файла, важнейшими из которых являются settings.py, urls.py и wsgi.py.
Файл settings.py определяет то, как Django взаимодействует с вашей системой и управляет вашим проектом.
Мы изменим некоторые из существующих настроек и добавим несколько новых настроек в ходе разработки проекта.
Файл urls.py сообщает Django, какие страницы следует строить в ответ на запросы браузера.
Файл wsgi.py помогает Django предоставлять созданные файлы (имя файла является сокращением от «Web Server Gateway
Interface»).

Создание базы данных
Так как Django хранит большую часть информации в базе данных, относящейся к проекту, на следующем этапе необходимо
создать базу данных, с которой Django сможет работать. Введите следующую команду (все еще не покидая активную среду):

        python manage.py migrate

Каждое изменение базы данных называется миграцией. Первое выполнение команды migrate приказывает Django проверить,
что база данных соответствует текущему состоянию проекта. Когда мы впервые выполняем эту команду в новом проекте
с использованием SQLite (вскоре мы расскажем о SQLite более подробно), Django создает новую базу данных за нас.
Django сообщает о создании и подготовке базы данных к хранению информации, необходимой для выполнения административных
операций и аутентификации.

В активной виртуальной среде для выполнения команд manage.py используется команда python, даже если для запуска
других программ вы используете другую команду (например, python3). В виртуальной среде команда python относится
к версии Python, создавшей виртуальную среду.

Убедимся в том, что проект был создан правильно. Введите команду для просмотра текущего состояния проекта:

        python manage.py runserver

Django запускает сервер, называемый сервером разработки, чтобы вы могли просмотреть проект в своей системе и проверить,
как он работает.

http://127.0.0.1:8000/ означает, что проект ведет прослушивание запросов на порте 8000 локального хоста.
Термином «локальный хост» (localhost, он же http://localhost:8000) обозначается сервер, который обрабатывает
только запросы вашей системы; он не позволяет никому другому просмотреть разрабатываемые страницы. Если вы получаете
сообщение об ошибке «Порт уже используется», прикажите Django использовать другой порт; для этого введите команду
python manage.py runserver 8001 и продолжайте перебирать номера портов по возрастанию, пока не найдете открытый порт.

Чтобы остановить сервер, нужно в терминале, где был запущен сервер нажать комбинацию клавиш:

        Ctrl+C

Проект Django представляет собой группу отдельных приложений, совместная работа которых обеспечивает работу
проекта в целом. Пока мы создадим одно приложение, которое будет выполнять большую часть работы в нашем проекте.

Оставьте сервер разработки выполняться в терминальном окне, открытом ранее. Откройте новое терминальное окно
(или вкладку) и перейдите в каталог learning_log. Активизируйте виртуальную среду и выполните команду:

        python manage.py startapp learning_logs

Команда startapp имя_приложения приказывает Django создать инфраструктуру, необходимую для построения приложения.
Заглянув сейчас в каталог проекта, вы найдете в нем новый подкаталог с именем learning_logs. Откройте этот каталог,
чтобы увидеть, какие файлы были созданы Django. Самые важные файлы в этом каталоге — models.py, admin.py и views.py.
Файл models.py будет использоваться для определения данных, которыми нужно управлять в нашем приложении. К файлам
admin.py и views.py мы вернемся позднее.

Определение моделей.
Модуль с именем models импортируется автоматически, и нам предлагается создать свои модели. Модель сообщает Django,
как работать с данными, которые будут храниться в приложении. С точки зрения кода модель представляет собой обычный
класс; она содержит атрибуты и методы, как и все остальные классы, рассматривавшиеся нами ранее.
Откроем файл models.py и создадим класс Topic - модель тем обсуждения, которые будут сохраняться пользователями.

Полный список всех полей, которые могут использоваться в модели, приведены в документе Django Model Field Reference
на https://docs.djangoproject.com/en/2.2/ref/models/fields/. Возможно, вся эта информация нам сейчас не понадобится,
но она будет в высшей степени полезной, когда вы начнете разрабатывать собственные приложения.

В файле setting.py есть секретный ключ, который необходимо держать в безопасности и никому не показывать, а также
не рекомендуется его хранить в репозитории. Лучше его хранить как переменную окружения. В операционной системе
windows ее можно сохранить так:

        Панель управления\Все элементы панели управления\Система -> Дополнительные параметры системы ->
        Переменные среды -> Переменные среды для пользователя -> Создать -> Новая пользовательская переменная ->
        -> Имя: SECRET_KEY, Значение: ...

В settings.py доваляем import os и и вместо значения ключа ставим SECRET_KEY = os.environ.get("SECRET_KEY")

Но если в проекте установлено виртуальное окружение как в нашем случае, то этот способ не будет работать.

Можно установить библиотеку decouple и сделать с ее помощью:

        pip install python-decouple

в файле settings.py добавить строку:

        from decouple import config

исправить значения SECRET_KEY и DEBUG:

        SECRET_KEY = config("SECRET_KEY")
        DEBUG = config("DEBUG", cast=bool)

Создать отдельно лежащий файл в удобном месте .env и в него добавить:

        SECRET_KEY=******  # вместо звездочек значение ключа без кавычек
        DEBUG=True  # или False, когда будет нужно

Добавить файл .env в .gitignore обязательно.

Активизация моделей.
Чтобы использовать модели, необходимо приказать Django включить приложение в общий проект.
Откройте файл settings.py (из каталога learning_log/learning_log) и найдите в нем раздел, который сообщает Django,
какие приложения установлены в проекте: INSTALLED_APPS. Добавим туда наше приложение.

Группировка приложений в проекте упрощает управление ими по мере того, как проект растет, а количество приложений
увеличивается. Здесь мы создаем раздел, который пока содержит только приложение learning_logs. Очень важно разместить
свои приложения перед приложениями по умолчанию на случай, если понадобится переопределить поведение таких приложений.

Затем необходимо приказать Django изменить базу данных для хранения информации, относящейся к модели Topic.
В терминальном окне введите следующую команду:

        python manage.py makemigrations learning_logs

По команде makemigrations Django определяет, как изменить базу данных для хранения информации, связанной с новыми
моделями. Из результатов видно, что создан файл миграции с именем 0001_initial.py. Эта миграция создает в базе
данных таблцицу для модели Topic.

Теперь применим миграцию для автоматического изменения базы данных:

        python manage.py migrate

Каждый раз, когда вы захотите изменить данные, которыми управляет Learning Log, выполните эти три действия:
внесите изменения в models.py, вызовите makemigrations для learning_logs и прикажите Django выполнить миграцию
проекта (migrate).

Административный сайт Django.
Django позволяет легко работать с моделями, определенными для приложения, через административный сайт. Этот сайт
используется администраторами сайта, а не рядовыми пользователями. В этом разделе мы создадим административный
сайт и используем его для добавления некоторых тем через модель Topic.

Создание суперпользователя.
Django позволяет создать пользователя, обладающего полным набором привилегий на сайте; такой пользователь называется
суперпользователем. Привилегии управляют действиями, которые разрешено выполнять пользователю. Для эффективного
администрирования веб-приложения владельцу сайта обычно должна быть доступна вся информация, хранящаяся на сайте.
Хороший администратор внимательно относится к конфиденциальной информации пользователя, потому что пользователи
доверяют тем приложениям, с которыми они работают. Чтобы создать суперпользователя в Django, введите следующую команду
и введите email adress, password, password (again):

        python manage.py createsuperuser

Часть конфиденциальной информации может быть скрыта от администраторов сайта. Например, Django на самом деле
не сохраняет введенный пароль; вместо этого сохраняется хеш — специальная строка, построенная на основе пароля.
И когда в будущем вы вводите пароль, Django снова хеширует введенные данные и сравнивает результат с хранимым хешем.
Если два хеша совпадают, то проверка пройдена. Если же хакер в результате атаки получит доступ к базе данных сайта,
то он сможет прочитать только хранящийся в базе хеш, но не пароли. При правильной настройке сайта восстановить исходные
пароли из хешей почти невозможно.

Регистрация модели на административном сайте.
Django добавляет некоторые модели (например, User и Group) на административный сайт автоматически, но модели,
которые мы создали, придется регистрировать вручную.

При запуске приложения learning_logs Django создает файл admin.py в одном каталоге с models.py. Откроем файл admin.py.
Чтобы зарегистрировать Topic на административном сайте, введите следующую команду:

        from .models import Topic
        admin.site.register(Topic)

Этот код импортирует регистрируемую модель Topic. Точка перед models сообщает Django, что файл models.py следует
искать в одном каталоге с admin.py. Вызов admin.site.register() сообщает Django, что управление моделью должно
осуществляться через административный сайт.
Теперь используя учетную запись суперпользователя войдем в панель администратора:

        http://localhost:8000/admin/

Добавление тем.
Когда модель Topic была зарегистрирована на административном сайте, добавим первую тему. Щелкните на ссылке Topics,
чтобы перейти к странице Topics; страница практически пуста, потому что еще нет ни одной темы для выполнения операций.
Щелкните на ссылке Add Topic; открывается форма для добавления новой темы. Введите в первом поле текст Chess и щелкните
на ссылке Save. Вы возвращаетесь к административной странице Topics, на которой появляется только что созданная тема.
Создадим вторую тему, чтобы у вас было больше данных для работы. Снова щелкните на ссылке Add Topic и создайте вторую
тему Rock Climbing. Ссылка Save снова возвращает вас к основной странице Topics, где отображаются обе темы,
Chess и Rock Climbing.

Определение модели Entry.
Чтобы сохранить информацию о том, что вы узнали по этим двум темам, необходимо определить модель для записей,
которые пользователь делает в своих журналах. Каждая запись должна ассоциироваться с конкретной темой.
Такое отношение называется отношением «многие к одному», поскольку многие записи могут быть связаны с одной темой.
Создадим модель Entry в файле models.py.

Миграция модели Entry.
Так как мы добавили новую модель, миграцию базы данных необходимо провести снова.
Вскоре вы привыкнете к этому процессу: вы изменяете models.py, выполняете команду:

        python manage.py makemigrations learning_logs
        python manage.py migrate

Команда генерирует новую миграцию с именем 0002_entry .py, которая сообщает Django, как изменить базу данных
для хранения информации, связанной с моделью Entry. При выдаче команды migrate Django подтверждает,
что применение миграции прошло успешно.

Регистрация Entry на административном сайте.
Модель Entry тоже необходимо зарегистрировать. Отредактируем файл admin.py.

Интерактивная оболочка Django.
Введенные данные можно проанализировать на программном уровне в интерактивном терминальном сеансе.
Эта интерактивная среда, называемая оболочкой (shell) Django, прекрасно подходит для тестирования
и диагностики проекта. Запуск интерактивной оболочки:

        python manage.py shell

>>> from learning_logs.models import Topic  # делаем импорт модели Topic
>>> Topic.objects.all()  # Метод для получения всех экземпляров модели Topic
<QuerySet [<Topic: Chess>, <Topic: Rock Climbing>]>  # возвращаемый список называется итоговым набором
>>> topics = Topic.objects.all()  # можем дать имя итоговому набору
>>> for topic in topics:  # переребрать содержимое с помощью цикла
...     print(topic.id, topic)  # Просмотр идентификаторов, назначенных каждому объекту темы
...
1 Chess  # зная идентификатор объекта можно проанализировать его атрибуты методом Topic.objects.get()
2 Rock Climbing
>>>
>>> t = Topic.objects.get(id=1)
>>> t.text  # вывод атрибута text
'Chess'
>>> t.date_added  # вывод атрибута date_added
datetime.datetime(2022, 2, 25, 21, 6, 15, 282274, tzinfo=datetime.timezone.utc)
>>>

Также можно просмотреть записи, относящиеся к конкретной теме. Ранее мы определили атрибут topic для модели Entry.
Он был экземпляром ForeighKey, представляющим связь между записью и темой. Django может использовать эту связь
для получения всех записей, относящихся к некоторой теме:

>>> t.entry_set.all()
<QuerySet [<Entry: Первая пробная запись в тему Chess...>, <Entry: Вторая пробная запись в тему Chess...>]>
>>>

Чтобы получить данные через отношение внешнего ключа, воспользуйтесь именем связанной модели, записанным
в нижнем регистре, за которым следует символ подчеркивания и слово set. Допустим, у вас имеются модели Pizza и Topping
и модель Topping связана с Pizza через внешний ключ. Если ваш объект называется my_pizza, для получения всех
связанных с ним экземпляров Topping используется выражение my_pizza.topping_set.all().

Мы будем использовать такой синтаксис при переходе к программированию страниц, которые могут запрашиваться
пользователями. Оболочка очень удобна тогда, когда вы хотите проверить, что ваш код получает нужные данные.
Если в оболочке код работает так, как задумано, можно ожидать, что он будет правильно работать и в файлах,
которые вы создаете в своем проекте. Если код выдает ошибки или не загружает те данные, которые должен загружать,
вам будет намного проще отладить его в простой оболочке, чем при работе с файлами, генерирующими веб-страницы.
В книге мы не будем часто возвращаться к оболочке, но вам не стоит забывать о ней — это полезный инструмент,
который поможет вам освоить синтаксис Django для работы с данными проекта.

При каждом изменении модели необходимо перезапустить оболочку, чтобы увидеть результаты этих изменений.
Чтобы завершить сеанс работы с оболочкой, нажмите Сtrl+D; в Windows нажмите Ctrl+Z, а затем Enter.

Выполнил упражнение 18.2: многоточие в названии темы в списке тем отображениется если название больше 50 символов
Выполненил упражнения 18.3: попробовал создать новую тему двумя способами и внести изменения в существующую тему.

Создание новой темы.
>>> from learning_logs.models import Topic
>>> tp = Topic(text="Exercise_18.3")  # создание новой темы
>>> tp.save()  # после создания нужно обязательно сохранить
>>>
>>> Topic.objects.create(text="Another way to create a topic")  # другой способ создания, сохраняется автоматически
<Topic: Another way to create a topic>

Внесение изменений в тему.
>>> tp.text = "Exercise_18.3 - create new topics and edit exists."  # можем внести изменения в существующую тему
>>> tp.save()  # после внесения изменений нужно сохранить эти изменения
>>>