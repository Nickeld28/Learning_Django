Cоздаем новый проект PyCharm, в нем должно быть установлено и активировано виртуальное окружение.

Включаем систему контроля версий VCS (GIT), создаем файл .gitignore и вносим исключения

Дальнейшие действия выполняем в активированной виртуальной среде.

Установка Django:

        pip install django

Делаем коммит:

        git commit

Импортируем проект в удаленный репозиторий:

        PyCharm -> VSC -> Import into Version Control -> Share Project on GitHub

Cоздаем папку с именем learning_log и в ней создаем проект с именем learning_log (с точкой в конце):

        django-admin startproject learning_log .

Django создает новый каталог с именем learning_log. Также создается файл manage.py — короткая программа, которая
получает команды и передает их соответствующей части Django для выполнения.
Мы используем эти команды для управления такими задачами, как работа с базами данных и запуск серверов.
В каталоге learning_log находятся четыре файла, важнейшими из которых являются settings.py, urls.py и wsgi.py.
Файл settings.py определяет то, как Django взаимодействует с вашей системой и управляет вашим проектом.
Мы изменим некоторые из существующих настроек и добавим несколько новых настроек в ходе разработки проекта.
Файл urls.py сообщает Django, какие страницы следует строить в ответ на запросы браузера.
Файл wsgi.py помогает Django предоставлять созданные файлы (имя файла является сокращением от «Web Server Gateway
Interface»).

Создание базы данных
Так как Django хранит большую часть информации в базе данных, относящейся к проекту, на следующем этапе необходимо
создать базу данных, с которой Django сможет работать. Введите следующую команду (все еще не покидая активную среду):

        python manage.py migrate

Каждое изменение базы данных называется миграцией. Первое выполнение команды migrate приказывает Django проверить,
что база данных соответствует текущему состоянию проекта. Когда мы впервые выполняем эту команду в новом проекте
с использованием SQLite (вскоре мы расскажем о SQLite более подробно), Django создает новую базу данных за нас.
Django сообщает о создании и подготовке базы данных к хранению информации, необходимой для выполнения административных
операций и аутентификации.

В активной виртуальной среде для выполнения команд manage.py используется команда python, даже если для запуска
других программ вы используете другую команду (например, python3). В виртуальной среде команда python относится
к версии Python, создавшей виртуальную среду.

Убедимся в том, что проект был создан правильно. Введите команду для просмотра текущего состояния проекта:

        python manage.py runserver

Django запускает сервер, называемый сервером разработки, чтобы вы могли просмотреть проект в своей системе и проверить,
как он работает.

http://127.0.0.1:8000/ означает, что проект ведет прослушивание запросов на порте 8000 локального хоста.
Термином «локальный хост» (localhost, он же http://localhost:8000) обозначается сервер, который обрабатывает
только запросы вашей системы; он не позволяет никому другому просмотреть разрабатываемые страницы. Если вы получаете
сообщение об ошибке «Порт уже используется», прикажите Django использовать другой порт; для этого введите команду
python manage.py runserver 8001 и продолжайте перебирать номера портов по возрастанию, пока не найдете открытый порт.

Чтобы остановить сервер, нужно в терминале, где был запущен сервер нажать комбинацию клавиш:

        Ctrl+C

Проект Django представляет собой группу отдельных приложений, совместная работа которых обеспечивает работу
проекта в целом. Пока мы создадим одно приложение, которое будет выполнять большую часть работы в нашем проекте.

Оставьте сервер разработки выполняться в терминальном окне, открытом ранее. Откройте новое терминальное окно
(или вкладку) и перейдите в каталог learning_log. Активизируйте виртуальную среду и выполните команду:

        python manage.py startapp learning_logs

Команда startapp имя_приложения приказывает Django создать инфраструктуру, необходимую для построения приложения.
Заглянув сейчас в каталог проекта, вы найдете в нем новый подкаталог с именем learning_logs. Откройте этот каталог,
чтобы увидеть, какие файлы были созданы Django. Самые важные файлы в этом каталоге — models.py, admin.py и views.py.
Файл models.py будет использоваться для определения данных, которыми нужно управлять в нашем приложении. К файлам
admin.py и views.py мы вернемся позднее.

Определение моделей.
Модуль с именем models импортируется автоматически, и нам предлагается создать свои модели. Модель сообщает Django,
как работать с данными, которые будут храниться в приложении. С точки зрения кода модель представляет собой обычный
класс; она содержит атрибуты и методы, как и все остальные классы, рассматривавшиеся нами ранее.
Откроем файл models.py и создадим класс Topic - модель тем обсуждения, которые будут сохраняться пользователями.

Полный список всех полей, которые могут использоваться в модели, приведены в документе Django Model Field Reference
на https://docs.djangoproject.com/en/2.2/ref/models/fields/. Возможно, вся эта информация нам сейчас не понадобится,
но она будет в высшей степени полезной, когда вы начнете разрабатывать собственные приложения.

В файле setting.py есть секретный ключ, который необходимо держать в безопасности и никому не показывать, а также
не рекомендуется его хранить в репозитории. Лучше его хранить как переменную окружения. В операционной системе
windows ее можно сохранить так:

        Панель управления\Все элементы панели управления\Система -> Дополнительные параметры системы ->
        Переменные среды -> Переменные среды для пользователя -> Создать -> Новая пользовательская переменная ->
        -> Имя: SECRET_KEY, Значение: ...

В settings.py доваляем import os и и вместо значения ключа ставим SECRET_KEY = os.environ.get("SECRET_KEY")

Но если в проекте установлено виртуальное окружение как в нашем случае, то этот способ не будет работать.

Можно установить библиотеку decouple и сделать с ее помощью:

        pip install python-decouple

в файле settings.py добавить строку:

        from decouple import config

исправить значения SECRET_KEY и DEBUG:

        SECRET_KEY = config("SECRET_KEY")
        DEBUG = config("DEBUG", cast=bool)

Создать отдельно лежащий файл в удобном месте .env и в него добавить:

        SECRET_KEY=******  # вместо звездочек значение ключа без кавычек
        DEBUG=True  # или False, когда будет нужно

Добавить файл .env в .gitignore обязательно.

Активизация моделей.
Чтобы использовать модели, необходимо приказать Django включить приложение в общий проект.
Откройте файл settings.py (из каталога learning_log/learning_log) и найдите в нем раздел, который сообщает Django,
какие приложения установлены в проекте: INSTALLED_APPS. Добавим туда наше приложение.

Группировка приложений в проекте упрощает управление ими по мере того, как проект растет, а количество приложений
увеличивается. Здесь мы создаем раздел, который пока содержит только приложение learning_logs. Очень важно разместить
свои приложения перед приложениями по умолчанию на случай, если понадобится переопределить поведение таких приложений.

Затем необходимо приказать Django изменить базу данных для хранения информации, относящейся к модели Topic.
В терминальном окне введите следующую команду:

        python manage.py makemigrations learning_logs

По команде makemigrations Django определяет, как изменить базу данных для хранения информации, связанной с новыми
моделями. Из результатов видно, что создан файл миграции с именем 0001_initial.py. Эта миграция создает в базе
данных таблцицу для модели Topic.

Теперь применим миграцию для автоматического изменения базы данных:

        python manage.py migrate

Каждый раз, когда вы захотите изменить данные, которыми управляет Learning Log, выполните эти три действия:
внесите изменения в models.py, вызовите makemigrations для learning_logs и прикажите Django выполнить миграцию
проекта (migrate).

Административный сайт Django.
Django позволяет легко работать с моделями, определенными для приложения, через административный сайт. Этот сайт
используется администраторами сайта, а не рядовыми пользователями. В этом разделе мы создадим административный
сайт и используем его для добавления некоторых тем через модель Topic.

Создание суперпользователя.
Django позволяет создать пользователя, обладающего полным набором привилегий на сайте; такой пользователь называется
суперпользователем. Привилегии управляют действиями, которые разрешено выполнять пользователю. Для эффективного
администрирования веб-приложения владельцу сайта обычно должна быть доступна вся информация, хранящаяся на сайте.
Хороший администратор внимательно относится к конфиденциальной информации пользователя, потому что пользователи
доверяют тем приложениям, с которыми они работают. Чтобы создать суперпользователя в Django, введите следующую команду
и введите email adress, password, password (again):

        python manage.py createsuperuser

Часть конфиденциальной информации может быть скрыта от администраторов сайта. Например, Django на самом деле
не сохраняет введенный пароль; вместо этого сохраняется хеш — специальная строка, построенная на основе пароля.
И когда в будущем вы вводите пароль, Django снова хеширует введенные данные и сравнивает результат с хранимым хешем.
Если два хеша совпадают, то проверка пройдена. Если же хакер в результате атаки получит доступ к базе данных сайта,
то он сможет прочитать только хранящийся в базе хеш, но не пароли. При правильной настройке сайта восстановить исходные
пароли из хешей почти невозможно.

Регистрация модели на административном сайте.
Django добавляет некоторые модели (например, User и Group) на административный сайт автоматически, но модели,
которые мы создали, придется регистрировать вручную.

При запуске приложения learning_logs Django создает файл admin.py в одном каталоге с models.py. Откроем файл admin.py.
Чтобы зарегистрировать Topic на административном сайте, введите следующую команду:

        from .models import Topic
        admin.site.register(Topic)

Этот код импортирует регистрируемую модель Topic. Точка перед models сообщает Django, что файл models.py следует
искать в одном каталоге с admin.py. Вызов admin.site.register() сообщает Django, что управление моделью должно
осуществляться через административный сайт.
Теперь используя учетную запись суперпользователя войдем в панель администратора:

        http://localhost:8000/admin/

Добавление тем.
Когда модель Topic была зарегистрирована на административном сайте, добавим первую тему. Щелкните на ссылке Topics,
чтобы перейти к странице Topics; страница практически пуста, потому что еще нет ни одной темы для выполнения операций.
Щелкните на ссылке Add Topic; открывается форма для добавления новой темы. Введите в первом поле текст Chess и щелкните
на ссылке Save. Вы возвращаетесь к административной странице Topics, на которой появляется только что созданная тема.
Создадим вторую тему, чтобы у вас было больше данных для работы. Снова щелкните на ссылке Add Topic и создайте вторую
тему Rock Climbing. Ссылка Save снова возвращает вас к основной странице Topics, где отображаются обе темы,
Chess и Rock Climbing.

Определение модели Entry.
Чтобы сохранить информацию о том, что вы узнали по этим двум темам, необходимо определить модель для записей,
которые пользователь делает в своих журналах. Каждая запись должна ассоциироваться с конкретной темой.
Такое отношение называется отношением «многие к одному», поскольку многие записи могут быть связаны с одной темой.
Создадим модель Entry в файле models.py.

Миграция модели Entry.
Так как мы добавили новую модель, миграцию базы данных необходимо провести снова.
Вскоре вы привыкнете к этому процессу: вы изменяете models.py, выполняете команду:

        python manage.py makemigrations learning_logs
        python manage.py migrate

Команда генерирует новую миграцию с именем 0002_entry .py, которая сообщает Django, как изменить базу данных
для хранения информации, связанной с моделью Entry. При выдаче команды migrate Django подтверждает,
что применение миграции прошло успешно.

Регистрация Entry на административном сайте.
Модель Entry тоже необходимо зарегистрировать. Отредактируем файл admin.py.

Интерактивная оболочка Django.
Введенные данные можно проанализировать на программном уровне в интерактивном терминальном сеансе.
Эта интерактивная среда, называемая оболочкой (shell) Django, прекрасно подходит для тестирования
и диагностики проекта. Запуск интерактивной оболочки:

        python manage.py shell

>>> from learning_logs.models import Topic  # делаем импорт модели Topic
>>> Topic.objects.all()  # Метод для получения всех экземпляров модели Topic
<QuerySet [<Topic: Chess>, <Topic: Rock Climbing>]>  # возвращаемый список называется итоговым набором
>>> topics = Topic.objects.all()  # можем дать имя итоговому набору
>>> for topic in topics:  # переребрать содержимое с помощью цикла
...     print(topic.id, topic)  # Просмотр идентификаторов, назначенных каждому объекту темы
...
1 Chess  # зная идентификатор объекта можно проанализировать его атрибуты методом Topic.objects.get()
2 Rock Climbing
>>>
>>> t = Topic.objects.get(id=1)
>>> t.text  # вывод атрибута text
'Chess'
>>> t.date_added  # вывод атрибута date_added
datetime.datetime(2022, 2, 25, 21, 6, 15, 282274, tzinfo=datetime.timezone.utc)
>>>

Также можно просмотреть записи, относящиеся к конкретной теме. Ранее мы определили атрибут topic для модели Entry.
Он был экземпляром ForeighKey, представляющим связь между записью и темой. Django может использовать эту связь
для получения всех записей, относящихся к некоторой теме:

>>> t.entry_set.all()
<QuerySet [<Entry: Первая пробная запись в тему Chess...>, <Entry: Вторая пробная запись в тему Chess...>]>
>>>

Чтобы получить данные через отношение внешнего ключа, воспользуйтесь именем связанной модели, записанным
в нижнем регистре, за которым следует символ подчеркивания и слово set. Допустим, у вас имеются модели Pizza и Topping
и модель Topping связана с Pizza через внешний ключ. Если ваш объект называется my_pizza, для получения всех
связанных с ним экземпляров Topping используется выражение my_pizza.topping_set.all().

Мы будем использовать такой синтаксис при переходе к программированию страниц, которые могут запрашиваться
пользователями. Оболочка очень удобна тогда, когда вы хотите проверить, что ваш код получает нужные данные.
Если в оболочке код работает так, как задумано, можно ожидать, что он будет правильно работать и в файлах,
которые вы создаете в своем проекте. Если код выдает ошибки или не загружает те данные, которые должен загружать,
вам будет намного проще отладить его в простой оболочке, чем при работе с файлами, генерирующими веб-страницы.
В книге мы не будем часто возвращаться к оболочке, но вам не стоит забывать о ней — это полезный инструмент,
который поможет вам освоить синтаксис Django для работы с данными проекта.

При каждом изменении модели необходимо перезапустить оболочку, чтобы увидеть результаты этих изменений.
Чтобы завершить сеанс работы с оболочкой, нажмите Сtrl+D; в Windows нажмите Ctrl+Z, а затем Enter.

Выполнил упражнение 18.2: многоточие в названии темы в списке тем отображениется если название больше 50 символов
Выполненил упражнения 18.3: попробовал создать новую тему двумя способами и внести изменения в существующую тему.

Создание новой темы.
>>> from learning_logs.models import Topic
>>> tp = Topic(text="Exercise_18.3")  # создание новой темы
>>> tp.save()  # после создания нужно обязательно сохранить
>>>
>>> Topic.objects.create(text="Another way to create a topic")  # другой способ создания, сохраняется автоматически
<Topic: Another way to create a topic>

Внесение изменений в тему.
>>> tp.text = "Exercise_18.3 - create new topics and edit exists."  # можем внести изменения в существующую тему
>>> tp.save()  # после внесения изменений нужно сохранить эти изменения
>>>

Выполнил упражнение 18.4: Создал новый проект, создал приложение, добавил модели, добавил приложение в settings.py,
добавил модели на административный сайт, создал файл .env, сохранил там SECRET_KEY и DEBUG из settings.py.,
создал суперпользователя, осуществил миграции, запустил сервер, добавил объекты для моделей Pizza и Topping.
Запустил интерактивную оболочку и вывел полный список объектов моделей Pizza и Topping.

Learning_Django>mkdir pizzeria
Learning_Django>cd pizzeria
Learning_Django\pizzeria>django-admin startproject pizzeria .
Learning_Django\pizzeria>python manage.py startapp pizzas
Learning_Django\pizzeria>python manage.py makemigrations
Learning_Django\pizzeria>python manage.py migrate
Learning_Django\pizzeria>python manage.py createsuperuser
Learning_Django\pizzeria>python manage.py makemigrations pizzas
Learning_Django\pizzeria>python manage.py migrate
Learning_Django\pizzeria>python manage.py runserver
Learning_Django\pizzeria>python manage.py shell
(InteractiveConsole)
>>> from pizzas.models import Topping, Pizza
>>> Topping.objects.all()
<QuerySet [<Topping: pepperoni>, <Topping: mushrooms>, <Topping: green peppers>, <Topping: fresh mozzarella>,
<Topping: tomatoes>, <Topping: basil leaves>, <Topping: onion>, <Topping: anchovies>, <Topping: bits of tomato>,
<Topping: cheddar>, <Topping: feta cheese>, <Topping: red onion>, <Topping: chicken>, <Topping: artichokes>,
<Topping: goat cheese and egg>, <Topping: tomato sauce>, <Topping: olives>, <Topping: Wisconsin brick cheese>]>
>>> Pizza.objects.all()
<QuerySet [<Pizza: Greek Pizza>, <Pizza: Chicago Pizza>, <Pizza: Sicilian Pizza>, <Pizza: Neapolitan Pizza>,
<Pizza: California Pizza>, <Pizza: Detroit Pizza>]>
>>>

Создание страниц: домашняя страница Learning Log.
Обычно процесс создания веб-страниц в Django состоит из трех стадий: определения URL, написания представлений
и написания шаблонов. Сначала следует определить схемы (patterns) URL. Схема URL описывает структуру URL-адреса
и сообщает Django, на какие компоненты следует обращать внимание при сопоставлении запроса браузера с URL-адресом
на сайте, чтобы выбрать возвращаемую страницу. Затем каждый URL-адрес связывается с конкретным представлением — функция
представление читает и обрабатывает данные, необходимые странице. Функция представления часто вызывает шаблон,
который строит страницу, подходящую для передачи браузеру. Так как мы сейчас всего лишь убеждаемся в том, что
Learning Log работает как положено, страница пока останется простой.

Сопоставление URL.
Пользователь запрашивает страницы, вводя URL-адреса в браузере и щелкая на ссылках, поэтому мы должны решить,
какие URL-адреса понадобятся в нашем проекте. Начнем с URL домашней страницы: это базовый адрес, используемый для
обращения к проекту. На данный момент базовый URL-адрес http://localhost:8000/ возвращает сайт, сгенерированный
Django по умолчанию; он сообщает о том, что проект был создан успешно. Мы изменим домашнюю страницу, связав базовый
URL-адрес с домашней страницей Learning Log. В каталоге проекта learning_log откройте файл urls.py для добавления
строки включения модуля learning_logs.urls. Файл urls.py по умолчанию находится в каталоге learning_log; теперь
нужно создать второй файл urls.py в папке learning_logs и прописать туда несколько строк кода (см. файл urls.py).

        learning_log>cd learning_logs
        learning_log\learning_logs\>NUL>urls.py

Чтобы было понятно, с какой версией urls.py мы работаем, в начало файла добавляется строка документации.
Затем импортируется функция path, она необходима для связывания URL с представлениями. Также импортируется модуль
views; точка приказывает Python импортировать представления из каталога, в котором находится текущий модуль urls.py.
Переменная app_name помогает Django отличить этот файл urls.py от одноименных файлов в других приложениях в проекте.
Переменная urlpatterns в этом модуле представляет собой список страниц, которые могут запрашиваться из приложения
learning_logs.

Схема URL представляет собой вызов функции path() с тремя аргументами. Первый аргумент содержит строку, которая
помогает Django правильно маршрутизировать текущий запрос. Django получает запрашиваемый URL и пытается отобразить
его на представление. Для этого Django ищет среди всех определенных схем URL ту, которая соответствует текущему запросу.
Базовый URL-адрес проекта (http://localhost:8000/) игнорируется, так что пустая строка совпадает с базовым URL-адресом.
Любой другой URL-адрес не будет соответствовать этому выражению, и Django вернет страницу с ошибкой, если запрашиваемый
URL не соответствует ни одной из существующих схем URL.

Второй аргумент функции path() определяет вызываемую функцию из views.py. Когда запрашиваемый URL-адрес соответствует
регулярному выражению, Django вызывает index() из views.py (мы напишем эту функцию представления в следующем разделе).
Третий аргумент определяет имя index для этой схемы URL, чтобы на нее можно было ссылаться в других частях кода.
Каждый раз, когда потрубуется предоставить ссылку на домашнюю страницу, мы будем использоватьь это имя вместо URL.

Написание представления (views).
Функция представления получает информацию из запроса, подготавливает данные, необходимые для построения страницы, и
возвращает данные браузеру - часто с исползованием шаблона, определяющего внешний вид страницы.

Файл views.py в learning_logs был сгенерирован автоматически при выполнении команды python manage.py startapp.
На данный момент файл только импортирует функцию render(), которая генерирует ответ на основании данных, полученных
от представлений. Пора отредактировать файл views.py (см. файл).

Если URL запроса совпадает с только что определенной схемой, Django ищет в файле views .py функцию с именем index(),
после чего передает этой функции представления объект request. В нашем случае никакая обработка данных для страницы
не нужна, поэтому код функции сводится к вызову render(). Функция render() использует два аргумента — исходный объект
запроса и шаблон, используемый для построения страницы. Давайте напишем этот шаблон.

Написание шаблона страницы.
Шаблон определяет общий вид страницы, а django заполняет его соответствующими данными при каждом запросе страницы.
Шаблон может обращаться к любым данным, полученным от представления. Так как наше представление домашней страницы
никаких данных не предоставляет, шаблон получается относительно простым.
В каталоге learning_logs создадим новый каталог с именем templates. В этом каталоге создадим другой каталог с именем
learning_logs. На первый взгляд такая структура кажется избыточной, но созданная таким образом структура будет
однозначно интерпретироваться django даже в контексте большого проекта, состоящего из множества отдельных приложений.
Во внутреннем каталоге learning_logs создадим новый файл с именем index.html

        learning_log>cd learning_logs
        learning_log\learning_logs>mkdir templates
        learning_log\learning_logs>cd templates
        learning_log\learning_logs\templates>mkdir learning_logs
        learning_log\learning_logs\templates>cd learning_logs
        learning_log\learning_logs\templates\learning_logs>NUL>index.html

Это очень простой файл, теги <p></p> обозначают абзацы. Тег <p> открывает абзац, а тег </p> закрывает его.
В нашей странице два абзаца: первый содержит заголовок, а второй описывает, что пользователь может сделать с помощью
приложения Learning Log. Теперь при запросе базового URL-адреса проекта http://localhost:8000/ вы увидите только что
построенную страницу вместо страницы по умолчанию. Django берет запрошенный URL-адрес и видит, что он совпадает
со схемой ''; в этом случае Django вызывает функцию views.index(), что приводит к построению страницы с использованием
шаблона, содержащегося в index.html.

И хотя может показаться, что для одной страницы этот процесс слишком сложен, такое разделение URL-адресов,
представлений и шаблонов работает хорошо. Оно позволяет сосредоточиться на отдельных аспектах проекта, а в более
крупных проектах отдельные участники могут сосредоточиться на тех областях, в которых они наиболее сильны. Например,
специалист по базам данных может заняться моделями, программист — кодом представления, а веб-дизайнер —шаблонами.

ПРИМЕЧАНИЕ.
Вы можете получить следующее сообщение об ошибке: ModuleNotFoundError: No module named 'learning_logs.urls'
В таком случае перезапустите сервер разработки каждый раз, когда вы сталкиваетесь с подобными ошибками.

Выполнил упражнение 18.5: Создал каталог meal_planner под проект, внутри него проект django.
Создал файл .env и засекретил SECRET_KEY и DEBUG, аналогично как в предыдущих проектах.
Создал приложение meal_plans, добавил его в settings.py и выполнил миграцию. Создал файл urls.py в meal_plans.
Внес изменения в файл urls.py в папке meal_planner. Внес изменения в файл views.py. В meal_plans создал каталог
templates, а внутри создал еще каталог meal_plans, а в нем файл index.html.
Запустил сервер, убедился в отображении домашней страницы.

    Learning_Django>md meal_planner
    Learning_Django>cd meal_planner
    meal_planner>django-admin startproject meal_planner .
    meal_planner>python manage.py startapp meal_plans
    meal_planner>python manage.py migrate
    meal_planner>cd meal_plans
    meal_planner\meal_plans\>NUL>urls.py
    meal_planner\meal_plans>md templates
    meal_planner\meal_plans>cd templates
    meal_planner\meal_plans\templates>md meal_plans
    meal_planner\meal_plans\templates>cd meal_plans
    meal_planner\meal_plans\templates\meal_plans>NUL>index.html

Выполнил упражнение 18.6: Создал файл urls.py в pizzeria/pizzas. Внес изменения в файл urls.py в папке pizzeria.
Внес изменения в файл views.py. В pizzas создал каталог templates, а внутри создал еще каталог pizzas,
а в нем файл index.html. Запустил сервер, убедился в отображении домашней страницы.

Построение других страниц.
Теперь можно переходить к построениею проекта Learning Log. Создадим две страницы для ввода данных: на одной будет
выводиться список всех тем, а на другой - все записи по конкретной теме. Для каждой страницы мы создадим схему URL,
напишем функцию представления и создадим шаблон. Но прежде стоит создать базовый шаблон, от которого будут наследовать
все шаблоны этого проекта.

Наследование шаблонов.
При построении сайта некоторые элементы почти всегда повторяются на каждой странице. Вместо того, чтобы встраивать эти
элементы непосредственно в страницы, вы можете написать базовый шаблон с повторяющимися элементами; все страницы будут
наследовать от этого шаблона. Такое решение позволит сосредоточиться на разработке уникальных аспектов каждой страницы
и существенно упростит изменение общего оформления проекта в целом.

Родительский шаблон.
Начнем с создания шаблона base.html в одном каталоге с файлом index.html. Пока единственным элементом, который будет
повторяться на каждой странице, остается заголовок в верхней части страницы. Так как шаблон будет включаться в каждую
страницу, преобразуем заголовок в ссылку на домашнюю страницу. Первая часть файла создает абзац с именем проекта,
который также работает как ссылка на домашнюю страницу. Для построения ссылки использовался шаблонный тег, обозначенный
фигурными скобками и знаками процента {% %}. Шаблонный тег представляет собой блок кода, который генерирует информацию
для вывода на странице. В данном примере шаблонный тег генерирует URL-адрес, соответствующий схеме URL, определенной
в файле learning_logs/urls.py с именем 'index'. В данном примере learning_logs - пространство имен, а index - схема URL
с уникальным именем в этом пространстве имен. Пространство имен определяется значением, присвоенным app_name в файле
learning_logs/urls.py. В этой странице HTML ссылка заключатся в якорный тег:<a href="url_ссылки">текст ссылки</a>.

Генерирование URL-адреса шаблонным тегом существенно упрощает актуализацию ссылок. Чтобы изменить URL-адрес в проекте,
достаточно изменить схему URL в urls.py, а django автоматически вставит обновленный URL-адрес ири следующем запросе
страницы. Каждая страница в проекте будет наследовать base.html, так что в дальнейшем на каждой странице будет ссылка
на домашнюю страницу. В конце файла base.html находится пара тегов block. Блок с именем content резервирует место;
информация, попадающая в блок content, будет определяться дочерним шаблоном. Дочерний шаблон не обязан определять
каждый блок в своем родителе, так что в родительских шаблонах можно зарезервировать место для любого количества блоков,
а дочерний шаблон будет использовать столько из них, сколько потребуется.

ПРИМЕЧАНИЕ.
В коде Python почти всегда используются отступы в четыре пробела. Файлы шаблонов обычно имеют больший уровень
вложенности, чем файлы Python, поэтому каждый уровень отступа обычно обозначается двумя пробелами. Будьте внимательны.

Дочерний шаблон.
Теперь нужно переписать файл index.html так, чтобы он наследовал от base.html.
Сравнивая этот файл с исходной версией index.html, мы видим, что заголовок Learning Log заменен кодом наследования
от родительского шаблона. В первой строке дочернего шаблона должен находится те {% extends %}, который сообщает django,
от какого родительского шаблона он наследует. Файл base.html является частью learning_logs, поэтому learning_logs
включается в путь к родительскому шаблону. Эта строка извлекает все содержимое из шаблона base.html и позволяет файлу
index.html определить, что должно попасть в пространство, зарезервированное блоком content. Все что не наследуется от
родительского шаблона попадает в блок content. Чтобы изменить общий для многих страниц элемент, достаточно изменить
его в родительском шаблоне. Внесенные изменения будут автоматически перенесены на каждую страницу, наследующую от этого
шаблона. В большом проекте такая структура значительно упрощает и ускоряет работу сайта.

ПРИМЕЧАНИЕ.
В больших проектах часто создается один родительский шаблон base.html для всего сайта и родительские шаблоны для
каждого крупного раздела сайта. Все шаблоны разделов наследуют от base.html, и каждая страница сайта наследует от
шаблона раздела. При такой структуре вы сможете легко изменять оформление и поведение сайта в целом, любого его раздела
или отдельной страницы. Данная конфигурация сильно повышает эффективность работы и стимулирует разработчика
к дальнейшему совершенствованию сайта .

Страница со списком тем.
Сделаем страницу, на которой будет выводиться перечень всех тем, созданных пользователями, это первая страница,
на которой на придется работать с данными.

Схема URL для тем.
Определим URL для страницы тем. Обычно в таких случаях выбирается простой фрагмент URL, который отражает суть
информации, представленной на странице. Мы воспользуемся словом topics, так что для получения страницы будет
использоваться URL http://localhost:8000/topics/. Следует внести изменения в learning_logs/urls.py.
Добавим topics/ в аргумент регулярного выражения, используемый с URL-адресом домашней страницы. Когда Django проверяет
запрашиваемый URL-адрес, эта схема совпадет с любым URL-адресом, который состоит из базового URL-адреса и слова topics.
Слеш в конце можно включить, а можно не включать, но после слова topics ничего быть не должно, иначе схема не совпадет.
Любой запрос с URL-адресом, соответствующим этой схеме, будет передан функции topics() в views.py.

Представление topics (views.py).
Функция topics() должна получать данные из базы данных и отправлять их шаблону. Сначала импортируется модель, связанная
с нужными данными. Функции topics() необходим один параметр: объект request, полученный Django от сервера. Выдается
запрос к базе данных на получение объектов Topic, отсортированных по атрибуту date_added. Полученный итоговый набор
сохраняется в topics. Определяется контекст, который будет передаваться шаблону. Контекст представляет собой словарь,
в котором ключами являются имена, используемые в шаблоне для обращения к данным, а значениями — данные, которые должны
передаваться шаблону. В данном случае существует всего одна пара «ключ-значение», которая содержит набор тем,
отображаемых на странице. При построении страницы, использующей данные, функции render() передается переменная context,
а также объект request и путь к шаблону.

Шаблон topics.
Шаблон страницы со списком тем получает словарь context, чтобы шаблон мог использовать данные, предоставленные topics().
Создадим файл с именем topics.html в одном каталоге с index.html.

Сначала тег {% extends %} объявляет о наследовании от base.html, после чего открывается блок content. Тело страницы
содержит маркированный (bulleted) список введенных тем. В стандартном языке HTML маркированный список называется
неупорядоченным списком и обозначается тегами <ul></ul>. Далее находится другой шаблонный тег, эквивалентный циклу for,
для перебора списка topics из словаря context. Код, используемый в шаблоне, отличается от Python некоторыми важными
особенностями. Python использует отступы для обозначения строк, входящих в тело цикла. В шаблоне каждый цикл for должен
снабжаться явным тегом {% endfor %}, обозначающим конец цикла. В цикле каждая тема должна быть преобразована в элемент
маркированного списка. Чтобы вывести значение переменной в шаблоне, заключите ее имя в двойные фигурные скобки.
Фигурные скобки на странице не появятся; они всего лишь сообщают Django об использовании шаблонной переменной.
Код {{ topic }} будет заменен значением topic при каждом проходе цикла. Тег HTML <li></li> обозначает элемент списка.
Все, что находится между тегами, в паре тегов <ul></ul>, будет отображаться как элемент маркированного списка. Далее
находится шаблонный тег {% empty %}, который сообщает Django, что делать при отсутствии элементов в списке. В нашем
примере выводится сообщение о том, что темы еще не созданы. Последние две строки завершают цикл for и маркированный
список. Затем необходимо изменить базовый шаблон base.html и включить ссылку на страницу с темами.

Изменения в файл base.html.
После ссылки на домашнюю страницу добавляется дефис, после которого вставляется ссылка на страницу тем, которая также
представлена шаблонным тегом {% url %}. Эта строка приказывает Django сгенерировать ссылку, соответствую щую схеме URL
с именем 'topics' в learning_logs/urls.py. Обновляем домашнюю страницу в браузере, и видим ссылку Topics.

Страницы отдельных тем.
Следующим шагом станет создание страницы для вывода информации по одной теме, с названием темы и всеми записями по этой
теме. Мы снова определим новую схему URL, напишем представление и создадим шаблон. Кроме того, на странице со списком
тем каждый элемент маркированного списка будет преобразован в ссылку на соответствующую страницу отдельной темы.

Схема URL для отдельных тем.
Схема URL для страницы темы немного отличается от других схем URL, которые встречались нам ранее, потому что в ней
используется атрибут id темы для обозначения запрашиваемой темы. Например, если пользователь хочет просмотреть страницу
с подробной информацией по теме Chess (id=1), эта страница будет иметь URL-адрес http://localhost:8000/topics/1/.
Внесем правки в  learning_logs/urls.py.
Рассмотрим строку 'topics/<int:topic_id>/' в этой схеме URL. Первая часть строки сообщает Django, что искать следует
URL-адреса, у которых за базовым адресом идет слово topics. Вторая часть строки, /<int:topic_id>/, описывает целое
число, заключенное между двумя слешами; это целое число сохраняется в аргументе topic_id. Когда Django находит
URL-адрес, соответствующий этой схеме, вызывается функция представления topic(), в аргументе которой передается
значение, хранящееся в topic_id. Значение topic_id используется для получения нужной темы внутри функции.

Представление отдельной темы.
Внесем правки в views.py. Функция topic() должна получить тему и все связанные с ней записи из базы данных. Это первая
функция представления, которой требуется параметр, отличный от объекта request. Функция получает значение, совпавшее
с выражением /<int:topic_id>/, и сохраняет его в topic_id. Далее функция get() используется для получения темы
(по аналогии с тем, как мы это делали в оболочке Django). Далее загружаются записи, связанные с данной темой, и они
упорядочиваются по значению date_added: знак «минус» перед date_added сортирует результаты в обратном порядке, то есть
самые последние записи будут находиться на первых местах. Тема и записи сохраняются в словаре context, который
передается шаблону topic.html.

ПРИМЕЧАНИЕ.
Выражения для topic и entries обращающиеся к базе данных за конкретной информацией, называются запросами. Когда вы
пишете подобные запросы для своих проектов, сначала опробуйте их в оболочке Django. Вы сможете проверить результат
намного быстрее, чем если напишете представление и шаблон, а затем проверите результаты в браузере.

Шаблон отдельной темы.
В шаблоне должно отображаться название темы и текст записей. Также необходимо сообщить пользователю, если записей нет.
Создадим шаблон topic.html. Шаблон расширяет base.html, как и для всех страниц проекта. Затем выводится текущая тема
из шаблонной переменной {{ topic }}. Переменная topic доступна, потому что она включена в словарь context. Затем
создается маркированный список со всеми записями по теме; перебор записей осуществляется так же, как это делалось ранее
для тем. С каждым элементом списка связываются два значения: временная метка и полный текст каждой записи.
Для временной метки выводится значение атрибута date_added. В шаблонах Django вертикальная черта (|) представляет
фильтр — функцию, изменяющую значение шаблонной переменной. Фильтр date:'M d, Y H:i' выводит временные метки в формате
January 1, 2018 23:00. Следующаяьстрока выводит полное значение text (вместо первых 50 символов каждой записи).
Фильтр linebreaks следит за тем, чтобы длинный текст содержал разрывы строк в формате, поддерживаемом браузером
(вместо блока непрерывного текста). Шаблонный тег {% empty %} используется для вывода сообщения об отсутствии записей.

Ссылки на странице.
Прежде чем просматривать страницу отдельной темы в браузере, необходимо изменить шаблон списка тем, чтобы каждая тема
вела на соответствующую страницу. Внесем изменения в topics.html.
Шаблонный тег URL используется для генерирования ссылки на основании схемы URL из learning_logs с именем 'topic'.
Этой схеме URL необходим аргумент topic_id, поэтому в шаблонный тег URL добавляется атрибут topic.id. Теперь каждая
тема в списке представляет собой ссылку на страницу темы, например http://localhost:8000/topics/1/.
Если теперь обновить страницу тем и щелкнуть на теме, открывается страница с содержанием.

ПРИМЕЧАНИЕ.
Между topic.id и topic_id существует неочевидное, но важное различие. Выражение topic.id проверяет тему и получает
значение соответствующего идентификатора. Переменная topic_id содержит ссылку на этот идентификатор в коде. Если вы
столкнетесь с ошибками при работе с идентификаторами, убедитесь в том, что эти выражения используются правильно.

Выполнил упражнение 18.7: Посмотрел документацию по шаблонам.

Выполнил упражнение 18.8: изменил схему URL pizzas/urls.py. Добавил представлене для отображения списка видов пиццы
и топпингов для каждого вида пиццы, применив наследование шаблонов. Добавил файлы base.html, pizzas.html, pizza.html.

УЧЕТНЫЕ ЗАПИСИ ПОЛЬЗОВАТЕЛЕЙ
В этой главе мы построим формы, на которых пользователи смогут вводить свои темы и записи, а также редактировать
существующие данные. Затем будет реализована система проверки пользователей. Мы создадим страницу регистрации,
на которой пользователи смогут создавать учетные записи, и ограничим доступ к некоторым страницам для анонимных
пользователей. Затем некоторые функции представления будут изменены так, чтобы пользователь мог видеть только свои
собственные данные. Вы узнаете, как обеспечить безопасность и конфиденциальность данных пользователей.
В настоящее время данные могут вводиться только суперпользователем на административном сайте. Однако разрешать
пользователям работу на административном сайте явно нежелательно, поэтому мы воспользуемся средствами построения форм
Django для создания страниц, на которых пользователи смогут вводить данные.

Добавление новых тем.
Начнем с возможности создания новых тем. Страницы на базе форм добавляются практически так же, как и те страницы,
которые мы уже строили ранее: вы определяете URL, пишете функцию представления и создаете шаблон. Принципиальное
отличие — добавление нового модуля forms.py, содержащего функциональность форм.

Объект ModelForm
Любая страница, на которой пользователь может вводить и отправлять информацию, является формой, даже если на первый
взгляд она на форму не похожа. Когда пользователь вводит информацию, необходимо проверить, что он ввел корректные
данные, а не вредоносный код (например, код для нарушения работы сервера). Затем проверенная информация обрабатывается
и сохраняется в нужном месте базы данных. Django автоматизирует большую часть этой работы. Простейший способ построения
форм в Django основан на использовании класса ModelForm, который автоматически строит форму на основании существующих
моделей. Ваша первая форма будет создана в файле forms.py, который должен находиться в одном каталоге с models.py.

Создадим файл learning_logs/forms.py.
Сначала импортируется модуль forms и модель, с которой мы будем работать: Topic. Далее определяется класс с именем
TopicForm, наследующий от forms.ModelForm. Простейшая версия ModelForm состоит из вложенного класса Meta, который
сообщает Django, на какой модели должна базироваться форма и какие поля на ней должны находиться. Далее форма создается
на базе модели Topic, а на ней размещается только поле text. Последняя строка приказывает Django не генерировать
подпись для текстового поля.

URL-адрес для новой темы new_topic.
Как пользователь выбрал команду создания новой темы, он направляется по адресу http://localhost:8000/new_topic/.
Создадим схему для new_topic в learning_logs/urls.py. Эта схема URL будет отправлять запросы функции представления
new_topic(), которую сейчас необходимо создать.

Функция представления new_topic().
Функция new_topic() должна обрабатывать две разные ситуации: исходные запросы страницы new_topic (в этом случае должна
отображаться пустая форма) и обработка данных, отправленных на форме. Затем она должна перенаправить пользователя
обратно на страницу topics. Мы импортируем класс HttpResponseRedirect, который будет использоваться для перенаправления
пользователя к странице topics после отправки введенной темы. Функция reverse() определяет URL по заданной схеме URL
(то есть Django сгенерирует URL при запросе страницы). Также импортируется только что написанная форма TopicForm.

Запросы GET и POST.
При построении веб-приложений используются два основных типа запросов — GET и POST.
Запросы GET используются для страниц, которые только читают данные с сервера, а запросы POST обычно используются
в тех случаях, когда пользователь должен отправить информацию на форме. Для обработки всех наших форм будет
использоваться метод POST (существуют и другие разновидности запросов, но в нашем проекте они не используются).
Функция new_topic() получает в параметре объект запроса. Когда пользователь впервые запрашивает эту страницу, его
браузер отправляет запрос GET. Когда пользователь уже заполнил и отправил форму, его браузер отправляет запрос
POST. В зависимости от типа запроса мы определяем, запросил ли пользователь пустую форму (запрос GET) или предлагает
обработать заполненную форму (запрос POST). Метод запроса — GET или POST — проверяется. Если метод запроса отличен
от POST, вероятно, используется запрос GET, поэтому необходимо вернуть пустую форму (даже если это запрос другого типа,
это все равно безопасно). Мы создаем экземпляр TopicForm, сохраняем его в переменной form и отправляем форму шаблону
в словаре context. Так как при создании TopicForm аргументы не передавались, Django создает пустую форму, которая
заполняется пользователем. Если используется метод запроса POST, выполняется блок else, который обрабатывает данные,
отправленные в форме. Мы создаем экземпляр TopicForm и передаем ему данные, введенные пользователем, хранящиеся
в request.POST. Возвращаемый объект form содержит информацию, отправленную пользователем. Отправленную информацию
нельзя сохранять в базе данных до тех пор, пока она не будет проверена. Функция is_valid() проверяет, что все
обязательные поля были заполнены (все поля формы по умолчанию являются обязательными), а введенные данные соответствуют
типам полей — например, что длина текста меньше 200 символов, как было указано в файле models.py. Автоматическая
проверка избавляет нас от большого объема работы. Если все данные действительны, можно вызвать метод save(), который
записывает данные из формы в базу данных. После того как данные будут сохранены, страницу можно покинуть. Мы исполь-
зуем вызов redirect() для перенаправления браузера на страницу topics, на которой пользователь увидит только что
введенную им тему в общем списке тем. Переменная context определяется в конце функции представления, а страница
строится на базе шаблона new_topic.html, который будет создан на следующем шаге. Код размещается за пределами любых
блоков if; он выполняется при создании пустой формы, а также при определении того, что отправленная форма была
недействительной. Недействительная форма включает стандартные сообщения об ошибках, чтобы помочь пользователю передать
действительные данные.

Шаблон new_topic.
Теперь создадим новый шаблон с именем new_topic.html для отображения только что созданной формы.
Этот шаблон расширяет base.html, поэтому он имеет такую же базовую структуру, как и остальные страницы Learning Log.
Определяется форма HTML. Аргумент action сообщает серверу, куда передавать данные, отправленные формой; в данном случае
данные возвращаются функции представления new_topic(). Аргумент method приказывает браузеру отправить данные в запросе
типа POST. Django использует шаблонный тег {% csrf_token %} для предотвращения попыток получения несанкционированного
доступа к серверу (атаки такого рода называются межсайтовой подделкой запросов). Далее отображается форма; это наглядный
пример того, как легко в Django выполняются такие стандартные операции, как отображение формы. Чтобы автоматически
создать все поля, необходимые для отображения формы, достаточно включить шаблонную переменную {{ form.as_p }}.
Модификатор as_p приказывает Django отобразить все элементы формы в формате абзацев — это простой способ аккуратного
отображения формы. Django не создает кнопку отправки данных для форм, поэтому мы определяем в конце кода.

Создание ссылки на страницу new_topic.
Ссылка на страницу new_topic создается на странице topics.html.

Добавление новых записей
Теперь, когда пользователь может добавлять новые темы, он также захочет добавлять новые записи. Мы снова определим URL,
напишем новую функцию и шаблон и создадим ссылку на страницу. Но сначала нужно добавить в forms.py еще один класс.
Сначала в команду import к Topic добавляется Entry. Новый класс EntryForm наследует от forms.ModelForm и содержит
вложенный класс Meta с указанием модели, на которой он базируется, и поле, включаемое на форму. Полю 'text' снова
назначается пустая надпись. Далее включается атрибут widgets. Виджет (widget) представляет собой элемент формы HTML:
однострочное или многострочное текстовое поле, раскрывающийся список и т.д. Включая атрибут widgets, вы можете
переопределить виджеты, выбранные Django по умолчанию. Приказывая Django использовать элемент forms.Textarea, мы
настраиваем виджет ввода для поля 'text', чтобы ширина текстовой области составляла 80 столбцов вместо значения
по умолчанию 40. У пользователя будет достаточно места для создания содержательных записей.

URL-адрес для new_entry.
Необходимо включить аргумент topic_id в URL-адрес для создания новой записи, потому что запись должна ассоциироваться
с конкретной темой. URL мы добавляем в learning_logs/urls.py. Эта схема URL соответствует любому URL-адресу в форме
http://localhost:8000/new_entry/id/, где id — число, равное идентификатору темы. Код <int:topic_id> захватывает
числовое значение и сохраняет его в переменной topic_id. При запросе URL-адреса, соответствующего этой схеме, Django
передает запрос и идентификатор темы функции представления new_entry().

Функция представления new_entry().
Функция представления new_entry очень похожа на функцию добавления новой темы. Добавим код в файл views.py.
Мы обновляем команду import и включаем в нее только что созданный класс EntryForm. Определение new_entry() содержит
параметр topic_id для сохранения полученного значения из URL. Идентификатор темы понадобится для отображения страницы
и обработки данных формы, поэтому мы используем topic_id для получения правильного объекта темы. Далее проверяется
метод запроса: POST или GET. Блок if выполняется для запроса GET, и мы создаем пустой экземпляр EntryForm. Для метода
запроса POST мы обрабатываем данные, создавая экземпляр EntryForm, заполненный данными POST из объекта request. Затем
проверяется корректность данных формы. Если данные корректны, необходимо задать атрибут topic объекта записи перед
сохранением его в базе данных. При вызове save() мы включаем аргумент commit=False для того, чтобы создать новый объект
записи и сохранить его в new_entry, не сохраняя пока в базе данных. Мы присваиваем атрибуту topic объекта new_entry
тему, прочитанную из базы данных в начале функции, после чего вызываем save() без аргументов. В результате запись
сохраняется в базе данных с правильно ассоциированной темой. Вызов redirect() получает два аргумента — имя
представления, которому передается управление, и аргумент для функции представления. В данном случае происходит
перенаправление функции topic(), которой должен передаваться аргумент topic_id. Вызов перенаправляет пользователя
на страницу темы, для которой была создана запись, и пользователь видит новую запись в списке записей. В конце функции
создается словарь context, а страница строится на базе шаблона new_entry.html. Этот код выполняется для пустой формы
или для отправленной формы, которая была определена как недействительная.

Шаблон new_entry.
Шаблон new_entry похож на шаблон new_topic. В начале страницы выводится тема, чтобы пользователь мог видеть, в какую
тему добавляется новая запись. Тема также служит ссылкой на главную страницу этой темы. Аргумент action формы включает
значение topic_id из URL, чтобы функция представления могла связать новую запись с правильной темой. В остальном этот
шаблон почти не отличается от new_topic.html.

Создание ссылки на страницу new_entry.
Затем необходимо создать ссылку на страницу new_entry на каждой странице темы. Изменим файл topic.html. Ссылка
добавляется перед выводом записей, потому что добавление новой записи является самым частым действием на этой странице.
Теперь пользователь может добавить сколько угодно новых тем и новых записей по каждой теме. Опробуйте страницу
new_entry, добавив несколько записей для каждой из созданных вами тем.
